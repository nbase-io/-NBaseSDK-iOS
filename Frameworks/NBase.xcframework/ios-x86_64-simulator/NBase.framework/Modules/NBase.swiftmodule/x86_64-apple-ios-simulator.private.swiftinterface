// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
// swift-module-flags: -target x86_64-apple-ios15.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -module-name NBase
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Alamofire
import Apollo
import ApolloAPI
import AuthenticationServices
import CoreAPI
import CoreTelephony
import Foundation
import Logging
@_exported import NBase
import SocketIO
import StoreKit
import Swift
import SystemConfiguration
import UIKit
import WebKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
extension NBase.ReceiptItem {
  public init?(receiptInfo: NBase.ReceiptInfo)
}
@_hasMissingDesignatedInitializers public class SwiftyStoreKit {
  @objc deinit
}
extension NBase.SwiftyStoreKit {
  public class var canMakePayments: Swift.Bool {
    get
  }
  @discardableResult
  public class func retrieveProductsInfo(_ productIds: Swift.Set<Swift.String>, completion: @escaping (NBase.RetrieveResults) -> Swift.Void) -> any NBase.InAppRequest
  @discardableResult
  public class func purchaseProduct(_ productId: Swift.String, quantity: Swift.Int = 1, atomically: Swift.Bool = true, applicationUsername: Swift.String = "", simulatesAskToBuyInSandbox: Swift.Bool = false, completion: @escaping (NBase.PurchaseResult) -> Swift.Void) -> any NBase.InAppRequest
  public class func purchaseProduct(_ product: StoreKit.SKProduct, quantity: Swift.Int = 1, atomically: Swift.Bool = true, applicationUsername: Swift.String = "", simulatesAskToBuyInSandbox: Swift.Bool = false, paymentDiscount: NBase.PaymentDiscount? = nil, completion: @escaping (NBase.PurchaseResult) -> Swift.Void)
  public class func restorePurchases(atomically: Swift.Bool = true, applicationUsername: Swift.String = "", completion: @escaping (NBase.RestoreResults) -> Swift.Void)
  public class func completeTransactions(atomically: Swift.Bool = true, completion: @escaping ([NBase.Purchase]) -> Swift.Void)
  @available(iOS 14, tvOS 14, macOS 11, watchOS 7, macCatalyst 14, *)
  public class func onEntitlementRevocation(completion: @escaping ([Swift.String]) -> Swift.Void)
  public class func finishTransaction(_ transaction: any NBase.PaymentTransaction)
  public static var shouldAddStorePaymentHandler: NBase.ShouldAddStorePaymentHandler? {
    get
    set
  }
  public static var updatedDownloadsHandler: NBase.UpdatedDownloadsHandler? {
    get
    set
  }
  public class func start(_ downloads: [StoreKit.SKDownload])
  public class func pause(_ downloads: [StoreKit.SKDownload])
  public class func resume(_ downloads: [StoreKit.SKDownload])
  public class func cancel(_ downloads: [StoreKit.SKDownload])
}
extension NBase.SwiftyStoreKit {
  public static var localReceiptData: Foundation.Data? {
    get
  }
  @discardableResult
  public class func verifyReceipt(using validator: any NBase.ReceiptValidator, forceRefresh: Swift.Bool = false, completion: @escaping (NBase.VerifyReceiptResult) -> Swift.Void) -> (any NBase.InAppRequest)?
  @discardableResult
  public class func fetchReceipt(forceRefresh: Swift.Bool, completion: @escaping (NBase.FetchReceiptResult) -> Swift.Void) -> (any NBase.InAppRequest)?
  public class func verifyPurchase(productId: Swift.String, inReceipt receipt: NBase.ReceiptInfo) -> NBase.VerifyPurchaseResult
  public class func verifySubscription(ofType type: NBase.SubscriptionType, productId: Swift.String, inReceipt receipt: NBase.ReceiptInfo, validUntil date: Foundation.Date = Date()) -> NBase.VerifySubscriptionResult
  public class func verifySubscriptions(ofType type: NBase.SubscriptionType = .autoRenewable, productIds: Swift.Set<Swift.String>, inReceipt receipt: NBase.ReceiptInfo, validUntil date: Foundation.Date = Date()) -> NBase.VerifySubscriptionResult
  public class func getDistinctPurchaseIds(ofType type: NBase.SubscriptionType = .autoRenewable, inReceipt receipt: NBase.ReceiptInfo) -> Swift.Set<Swift.String>?
}
@_hasMissingDesignatedInitializers public class Query {
  public static func initialize(_ projectId: Swift.String, projectKey: Swift.String, storeId: Swift.String, language: Swift.String = "en", region: Swift.String = "en", completionHandler: @escaping (NBase.NBaseResult<Any?, NBase.NBaseError>) -> Swift.Void)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Mutation {
  public static func checkPurchase(productId: Swift.String, paymentId: Swift.String?, userdata: Swift.String?, completionHandler: @escaping (NBase.NBaseResult<Any?, NBase.NBaseError>) -> Swift.Void)
  public static func signInWithAnonymously(deviceId: Swift.String?, options: Swift.String?, completionHandler: @escaping (NBase.NBaseResult<Any?, NBase.NBaseError>) -> Swift.Void)
  public static func setMember(adid: Swift.String?, device: Swift.String?, network: Swift.String?, version: Swift.String?, model: Swift.String?, token: Swift.String?, push: Swift.Bool?, night: Swift.Bool?, ad: Swift.Bool?, agree_termsofuse: Swift.Bool?, agree_privacypolicy: Swift.Bool?, completionHandler: @escaping (NBase.NBaseResult<Any?, NBase.NBaseError>) -> Swift.Void)
  public static func createLinking(provider: Swift.String, memberId: Swift.String, username: Swift.String, password: Swift.String, email: Swift.String, completionHandler: @escaping (NBase.NBaseResult<Any?, NBase.NBaseError>) -> Swift.Void)
  public static func updateLinking(provider: Swift.String, memberId: Swift.String, username: Swift.String, email: Swift.String, completionHandler: @escaping (NBase.NBaseResult<Any?, NBase.NBaseError>) -> Swift.Void)
  public static func deleteLinking(linkingId: Swift.String, completionHandler: @escaping (NBase.NBaseResult<Any?, NBase.NBaseError>) -> Swift.Void)
  public static func createLogging(level: Swift.String, errorCode: Swift.String, message: Swift.String, completionHandler: @escaping (NBase.NBaseResult<Any?, NBase.NBaseError>) -> Swift.Void)
  public static func createPurchaseV3(orderId: Swift.String, receipt: Swift.String, signature: Swift.String, productId: Swift.String, storeId: Swift.String, country: Swift.String, paymentId: Swift.String, currency: Swift.String, serverId: Swift.String?, playerId: Swift.String?, metadata: Swift.String?, options: Swift.String?, authCode: Swift.String, level: Swift.Int?, price: Swift.Float64, userdata: Swift.String?, completionHandler: @escaping (NBase.NBaseResult<Any?, NBase.NBaseError>) -> Swift.Void)
  @objc deinit
}
@available(iOSApplicationExtension 11.2, iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 4.2, macCatalyst 13.0, *)
extension StoreKit.SKProductDiscount {
  public var localizedPrice: Swift.String? {
    get
  }
  public var localizedSubscriptionPeriod: Swift.String {
    get
  }
}
public struct NBUser {
  public let id: Swift.String?
  public let name: Swift.String?
  public let nickname: Swift.String?
  public let email: Swift.String?
  public let token: Swift.String?
  public let age: Swift.Int?
  public let birth: Swift.String
  public let sex: Swift.String?
  public let profile: Swift.String?
  public let mobile: Swift.String?
}
extension NBase.NBUser : Swift.Sendable {
}
extension NBase.NBUser : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public func encodeToBase64() -> Swift.String?
  public func encodeToJson() -> Swift.String?
}
public struct NBLink {
  public let id: Swift.String?
}
extension NBase.NBLink : Swift.Sendable {
}
extension NBase.NBLink : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public func encodeToBase64() -> Swift.String?
  public func encodeToJson() -> Swift.String?
}
public enum NBaseError : Swift.Error {
  case noPurchaseCancel
  case noPurchasePending
  case noPurchaseUnknown
  case failToConnect
  case failToDisconnect
  case noProjectId
  case noOrderId
  case noSignature
  case noProductId
  case failToStoreProduct
  case noAuthCode
  case noAppStoreAvailable
  case noProductProcess
  case noPurchaseVerified
  case noTransactionVerificationFailed
  case noProjectKey
  case noStoreId
  case noSocket
  case noFile
  case noFileName
  case noMimeType
  case noMessage
  case noThreadId
  case noUser
  case noUserId
  case noChannelId
  case noChannelType
  case noChannelName
  case noSubscriptionId
  case noPinId
  case notInitialized
  case failed(message: Swift.String)
}
extension NBase.NBaseError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public protocol InAppRequest : AnyObject {
  func start()
  func cancel()
}
public enum TransactionResult {
  case purchased(purchase: NBase.PurchaseDetails)
  case restored(purchase: NBase.Purchase)
  case deferred(purchase: NBase.PurchaseDetails)
  case failed(error: StoreKit.SKError)
}
public protocol PaymentQueue : AnyObject {
  func add(_ observer: any StoreKit.SKPaymentTransactionObserver)
  func remove(_ observer: any StoreKit.SKPaymentTransactionObserver)
  func add(_ payment: StoreKit.SKPayment)
  func start(_ downloads: [StoreKit.SKDownload])
  func pause(_ downloads: [StoreKit.SKDownload])
  func resume(_ downloads: [StoreKit.SKDownload])
  func cancel(_ downloads: [StoreKit.SKDownload])
  func restoreCompletedTransactions(withApplicationUsername username: Swift.String?)
  func finishTransaction(_ transaction: StoreKit.SKPaymentTransaction)
}
extension StoreKit.SKPaymentQueue : NBase.PaymentQueue {
}
extension StoreKit.SKPaymentTransaction {
  @objc override dynamic open var debugDescription: Swift.String {
    @objc get
  }
}
extension StoreKit.SKPaymentTransactionState : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct NBInitialize {
  public let status: Swift.Bool?
  public let language: Swift.String?
  public let country: Swift.String
  public let remote_ip: Swift.String?
  public let platform: Swift.String?
  public let sandbox: Swift.Bool?
}
extension NBase.NBInitialize : Swift.Sendable {
}
extension NBase.NBInitialize : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
  public func encodeToBase64() -> Swift.String?
  public func encodeToJson() -> Swift.String?
}
public struct PaymentDiscount {
  @available(iOS 12.2, tvOS 12.2, macOS 10.14.4, watchOS 6.2, macCatalyst 13.0, *)
  public init(discount: StoreKit.SKPaymentDiscount)
}
public class AppleReceiptValidator : NBase.ReceiptValidator {
  public enum VerifyReceiptURLType : Swift.String {
    case production
    case sandbox
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var service: NBase.AppleReceiptValidator.VerifyReceiptURLType
  public init(service: NBase.AppleReceiptValidator.VerifyReceiptURLType = .production, sharedSecret: Swift.String? = nil)
  public func validate(receiptData: Foundation.Data, completion: @escaping (NBase.VerifyReceiptResult) -> Swift.Void)
  @objc deinit
}
public let NBase: NBase.NBaseFramework
@_hasMissingDesignatedInitializers public class NBaseFramework {
  public static let `default`: NBase.NBaseFramework
  @objc deinit
}
extension NBase.NBaseFramework {
  public func log(with str: Swift.String)
  public func initialize(_ projectId: Swift.String, projectKey: Swift.String, storeId: Swift.String, language: Swift.String = "en", region: Swift.String = "en", completionHandler: @escaping (NBase.NBaseResult<NBase.NBInitialize?, NBase.NBaseError>) -> Swift.Void)
}
public struct GraphQLToken {
  public enum AuthType : Swift.String {
    case basic
    case bearer
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension StoreKit.SKProduct {
  public var localizedPrice: Swift.String? {
    get
  }
  @available(iOSApplicationExtension 11.2, iOS 11.2, macOS 10.13.2, tvOS 11.2, watchOS 6.2, macCatalyst 13.0, *)
  public var localizedSubscriptionPeriod: Swift.String {
    get
  }
}
@frozen public enum NBaseResult<Success, Failure> where Failure : Swift.Error {
  case success(Success)
  case failure(Failure)
}
public protocol Purchased {
  var productId: Swift.String { get }
  var quantity: Swift.Int { get }
  var originalPurchaseDate: Foundation.Date { get }
}
extension NBase.Purchase : NBase.Purchased {
  public var originalPurchaseDate: Foundation.Date {
    get
  }
}
extension NBase.PurchaseDetails : NBase.Purchased {
  public var originalPurchaseDate: Foundation.Date {
    get
  }
}
public struct Purchase {
  public let productId: Swift.String
  public let quantity: Swift.Int
  public let transaction: any NBase.PaymentTransaction
  public let originalTransaction: (any NBase.PaymentTransaction)?
  public let needsFinishTransaction: Swift.Bool
  public init(productId: Swift.String, quantity: Swift.Int, transaction: any NBase.PaymentTransaction, originalTransaction: (any NBase.PaymentTransaction)?, needsFinishTransaction: Swift.Bool)
}
public struct PurchaseDetails {
  public let productId: Swift.String
  public let quantity: Swift.Int
  public let product: StoreKit.SKProduct
  public let transaction: any NBase.PaymentTransaction
  public let originalTransaction: (any NBase.PaymentTransaction)?
  public let needsFinishTransaction: Swift.Bool
  public init(productId: Swift.String, quantity: Swift.Int, product: StoreKit.SKProduct, transaction: any NBase.PaymentTransaction, originalTransaction: (any NBase.PaymentTransaction)?, needsFinishTransaction: Swift.Bool)
}
public protocol ReceiptValidator {
  func validate(receiptData: Foundation.Data, completion: @escaping (NBase.VerifyReceiptResult) -> Swift.Void)
}
public protocol PaymentTransaction {
  var transactionDate: Foundation.Date? { get }
  var transactionState: StoreKit.SKPaymentTransactionState { get }
  var transactionIdentifier: Swift.String? { get }
  var downloads: [StoreKit.SKDownload] { get }
}
extension StoreKit.SKPaymentTransaction : NBase.PaymentTransaction {
}
public struct RetrieveResults {
  public let retrievedProducts: Swift.Set<StoreKit.SKProduct>
  public let invalidProductIDs: Swift.Set<Swift.String>
  public let error: (any Swift.Error)?
  public init(retrievedProducts: Swift.Set<StoreKit.SKProduct>, invalidProductIDs: Swift.Set<Swift.String>, error: (any Swift.Error)?)
}
public enum PurchaseResult {
  case success(purchase: NBase.PurchaseDetails)
  case deferred(purchase: NBase.PurchaseDetails)
  case error(error: StoreKit.SKError)
}
public struct RestoreResults {
  public let restoredPurchases: [NBase.Purchase]
  public let restoreFailedPurchases: [(StoreKit.SKError, Swift.String?)]
  public init(restoredPurchases: [NBase.Purchase], restoreFailedPurchases: [(StoreKit.SKError, Swift.String?)])
}
public typealias ShouldAddStorePaymentHandler = (_ payment: StoreKit.SKPayment, _ product: StoreKit.SKProduct) -> Swift.Bool
public typealias UpdatedDownloadsHandler = (_ downloads: [StoreKit.SKDownload]) -> Swift.Void
public typealias ReceiptInfo = [Swift.String : Swift.AnyObject]
public enum FetchReceiptResult {
  case success(receiptData: Foundation.Data)
  case error(error: NBase.ReceiptError)
}
public enum VerifyReceiptResult {
  case success(receipt: NBase.ReceiptInfo)
  case error(error: NBase.ReceiptError)
}
public enum VerifyPurchaseResult {
  case purchased(item: NBase.ReceiptItem)
  case notPurchased
}
public enum VerifySubscriptionResult {
  case purchased(expiryDate: Foundation.Date, items: [NBase.ReceiptItem])
  case expired(expiryDate: Foundation.Date, items: [NBase.ReceiptItem])
  case notPurchased
}
public enum SubscriptionType : Swift.Hashable {
  case autoRenewable
  case nonRenewing(validDuration: Foundation.TimeInterval)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: NBase.SubscriptionType, b: NBase.SubscriptionType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct ReceiptItem : NBase.Purchased, Swift.Codable {
  public var productId: Swift.String
  public var quantity: Swift.Int
  public var transactionId: Swift.String
  public var originalTransactionId: Swift.String
  public var purchaseDate: Foundation.Date
  public var originalPurchaseDate: Foundation.Date
  public var webOrderLineItemId: Swift.String?
  public var subscriptionExpirationDate: Foundation.Date?
  public var cancellationDate: Foundation.Date?
  public var isTrialPeriod: Swift.Bool
  public var isInIntroOfferPeriod: Swift.Bool
  public var isUpgraded: Swift.Bool
  public init(productId: Swift.String, quantity: Swift.Int, transactionId: Swift.String, originalTransactionId: Swift.String, purchaseDate: Foundation.Date, originalPurchaseDate: Foundation.Date, webOrderLineItemId: Swift.String?, subscriptionExpirationDate: Foundation.Date?, cancellationDate: Foundation.Date?, isTrialPeriod: Swift.Bool, isInIntroOfferPeriod: Swift.Bool, isUpgraded: Swift.Bool)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum ReceiptError : Swift.Error {
  case noReceiptData
  case noRemoteData
  case requestBodyEncodeError(error: any Swift.Error)
  case networkError(error: any Swift.Error)
  case jsonDecodeError(string: Swift.String?)
  case receiptInvalid(receipt: NBase.ReceiptInfo, status: NBase.ReceiptStatus)
}
public enum ReceiptStatus : Swift.Int {
  case unknown
  case none
  case valid
  case jsonNotReadable
  case malformedOrMissingData
  case receiptCouldNotBeAuthenticated
  case secretNotMatching
  case receiptServerUnavailable
  case subscriptionExpired
  case testReceipt
  case productionEnvironment
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum ReceiptInfoField : Swift.String {
  case bundle_id
  case application_version
  case original_application_version
  case creation_date
  case expiration_date
  case in_app
  public enum InApp : Swift.String {
    case quantity
    case product_id
    case transaction_id
    case original_transaction_id
    case purchase_date
    case original_purchase_date
    case expires_date
    case cancellation_date
    case app_item_id
    case version_external_identifier
    case web_order_line_item_id
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension NBase.AppleReceiptValidator.VerifyReceiptURLType : Swift.Equatable {}
extension NBase.AppleReceiptValidator.VerifyReceiptURLType : Swift.Hashable {}
extension NBase.AppleReceiptValidator.VerifyReceiptURLType : Swift.RawRepresentable {}
extension NBase.GraphQLToken.AuthType : Swift.Equatable {}
extension NBase.GraphQLToken.AuthType : Swift.Hashable {}
extension NBase.GraphQLToken.AuthType : Swift.RawRepresentable {}
extension NBase.ReceiptStatus : Swift.Equatable {}
extension NBase.ReceiptStatus : Swift.Hashable {}
extension NBase.ReceiptStatus : Swift.RawRepresentable {}
extension NBase.ReceiptInfoField : Swift.Equatable {}
extension NBase.ReceiptInfoField : Swift.Hashable {}
extension NBase.ReceiptInfoField : Swift.RawRepresentable {}
extension NBase.ReceiptInfoField.InApp : Swift.Equatable {}
extension NBase.ReceiptInfoField.InApp : Swift.Hashable {}
extension NBase.ReceiptInfoField.InApp : Swift.RawRepresentable {}
